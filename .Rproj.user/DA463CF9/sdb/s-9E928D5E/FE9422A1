{
    "collab_server" : "",
    "contents" : "\\name{pmh}\n\\alias{pmh}\n%- Also NEED an '\\alias' for EACH other topic documented here.\n\\title{\n%%  ~~function to do ... ~~\nA measure of departure from partial marginal homogeneity for square contingency tables\n}\n\\description{\n%%  ~~ A concise (1-5 lines) description of what the function does. ~~\nWhen we want to measure departure from partial marginal homogeneity for square contingency tables, we can use this function.\n}\n\\usage{\npmh(data = j_sight, lambda = 0)\n}\n%- maybe also 'usage' for other objects documented here.\n\\arguments{\n  \\item{data}{\n%%     ~~Describe \\code{data} here~~\nA square contingency table\n}\n  \\item{lambda}{\n%%     ~~Describe \\code{lambda} here~~\nlambda\n}\n}\n\\details{\n%%  ~~ If necessary, more details than the description above ~~\nAgain, when we want to measure departure from partial marginal homogeneity for square contingency tables, we can use this function.\n}\n\\value{\n%%  ~Describe the value returned\n%%  If it is a LIST, use\n%%  \\item{comp1 }{Description of 'comp1'}\n%%  \\item{comp2 }{Description of 'comp2'}\n%% ...\n}\n\\references{\n%% ~put references to the literature/web site here ~\n}\n\\author{\n%%  ~~who you are~~\nYtr\n}\n\\note{\n%%  ~~further notes~~\n}\n\n%% ~Make other sections like Warning with \\section{Warning }{....} ~\n\n\\seealso{\n%% ~~objects to See Also as \\code{\\link{help}}, ~~~\n}\n\\examples{\n##---- Should be DIRECTLY executable !! ----\n##-- ==>  Define data, use random,\n##--\tor do  help(data=index)  for the standard data sets.\n\n## The function is currently defined as\nfunction (data = j_sight, lambda = 0)\n{\n    if (1 == 2) {\n        lambda = 0\n    }\n    log0 = function(x) {\n        if (is.infinite(log(x))) {\n            res = 0\n        }\n        else {\n            res = log(x)\n        }\n        return(res)\n    }\n    p_ij = dat/sum(dat)\n    n.row = n.col = nrow(p_ij)\n    dp_ij = matrix(NA, n.row, n.col)\n    A = (2^lambda)/((2^lambda) - 1)\n    A2 = 1/log0(2)\n    p_id = c()\n    p_di = c()\n    p1rat = p2rat = c()\n    him = enm = lenm = pistar = c()\n    alln = sum(dat)\n    toriihim = toriienm = 1\n    for (i in 1:n.row) {\n        p_id[i] = sum(p_ij[i, ])\n        p_di[i] = sum(p_ij[, i])\n        p1rat[i] = p_id[i]/(p_id[i] + p_di[i])\n        p2rat[i] = p_di[i]/(p_id[i] + p_di[i])\n        him[i] = 1 - A * (1 - ((p1rat[i])^(lambda + 1)) - ((p2rat[i])^(lambda +\n            1)))\n        enm[i] = 1 + A2 * (p1rat[i] * log0(p1rat[i]) + p2rat[i] *\n            log0(p2rat[i]))\n        pistar[i] = (p_id[i] + p_di[i])/2\n        toriihim = toriihim * (him[i]^pistar[i])\n        toriienm = toriienm * (enm[i]^pistar[i])\n    }\n    if (lambda != 0) {\n        for (i in 1:n.row) {\n            for (j in 1:n.col) {\n                if (i == j) {\n                  dp_ij[i, j] = toriihim * (log0(him[i]) + A *\n                    (lambda + 1) * (p_id[i]^lambda - p_di[i]^lambda) *\n                    (p_di[i] - p_id[i])/(2 * him[i] * (p_id[i] +\n                    p_di[i])^(lambda + 1)))\n                }\n                else {\n                  dp_ij[i, j] = (1/2) * toriihim * (log0(him[i]) +\n                    A * (lambda + 1) * (p_id[i]^lambda - p_di[i]^lambda) *\n                      p_di[i]/(him[i] * (p_id[i] + p_di[i])^(lambda +\n                      1)) + log0(him[j]) + A * (lambda + 1) *\n                    (p_di[j]^lambda - p_id[j]^lambda) * p_id[j]/(him[j] *\n                    (p_id[j] + p_di[j])^(lambda + 1)))\n                }\n            }\n        }\n        Sigma1 = Sigma22 = 0\n        for (i in 1:n.row) {\n            for (j in 1:n.col) {\n                Sigma1 = Sigma1 + p_ij[i, j] * (dp_ij[i, j]^2)\n                Sigma22 = Sigma22 + p_ij[i, j] * dp_ij[i, j]\n            }\n        }\n        Sigma2 = Sigma22^2\n        Sigma = Sigma1 - Sigma2\n        CI.low = toriihim - qnorm(1 - 0.05/2) * sqrt(Sigma/alln)\n        CI.upper = toriihim + qnorm(1 - 0.05/2) * sqrt(Sigma/alln)\n    }\n    if (lambda == 0) {\n        for (i in 1:n.row) {\n            for (j in 1:n.col) {\n                if (i == j) {\n                  dp_ij[i, j] = toriienm * (log0(enm[i]) + A2 *\n                    (p_di[i] - p_id[i]) * log0(p_id[i]/p_di[i])/(2 *\n                    (p_id[i] + p_di[i]) * enm[i]))\n                }\n                else {\n                  dp_ij[i, j] = toriienm * (1/2) * (log0(enm[i]) +\n                    A2 * p_di[i] * log0(p_id[i]/p_di[i])/((p_id[i] +\n                      p_di[i]) * enm[i]) + log0(enm[j]) - A2 *\n                    p_id[j] * log0(p_id[j]/p_di[j])/((p_id[j] +\n                    p_di[j]) * enm[j]))\n                }\n            }\n        }\n        Sigma1 = Sigma22 = 0\n        for (i in 1:n.row) {\n            for (j in 1:n.col) {\n                Sigma1 = Sigma1 + p_ij[i, j] * (dp_ij[i, j]^2)\n                Sigma22 = Sigma22 + p_ij[i, j] * dp_ij[i, j]\n            }\n        }\n        Sigma2 = Sigma22^2\n        Sigma = Sigma1 - Sigma2\n        CI.low = toriienm - qnorm(1 - 0.05/2) * sqrt(Sigma/alln)\n        CI.upper = toriienm + qnorm(1 - 0.05/2) * sqrt(Sigma/alln)\n        toriihim = toriienm\n    }\n    return(list(dep = toriihim, vari = Sigma, CI = c(CI.low,\n        CI.upper)))\n  }\n}\n% Add one or more standard keywords, see file 'KEYWORDS' in the\n% R documentation directory.\n\\keyword{ ~kwd1 }\n\\keyword{ ~kwd2 }% __ONLY ONE__ keyword per line\n",
    "created" : 1489662577766.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3599690326",
    "id" : "FE9422A1",
    "lastKnownWriteTime" : 1489663780,
    "last_content_update" : 1489663780685,
    "path" : "~/pmh/man/pmh.Rd",
    "project_path" : "man/pmh.Rd",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_doc"
}